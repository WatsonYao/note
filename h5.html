<!DOCTYPE HTML>
<html>
<head>
	<style type="text/css">
		#div1 {width:488px;height:70px;padding:10px;border:1px solid #aaaaaa;}
	</style>
	<script type="text/javascript">
		function allowDrop(ev)
		{
			ev.preventDefault();
		}

		function drag(ev)
		{
			ev.dataTransfer.setData("Text",ev.target.id);
		}

		function drop(ev)
		{
			ev.preventDefault();
			var data=ev.dataTransfer.getData("Text");
			ev.target.appendChild(document.getElementById(data));
		}
	</script>
</head>
<body>

	<p>请把 W3School 的图片拖放到矩形中：</p>

	<div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
	<br />
	<img id="drag1" src="/i/w3school_banner.gif" draggable="true" ondragstart="drag(event)" />

</body>
</html>

<!-- 
代码解释：
调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）
通过 dataTransfer.getData("Text") 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。
被拖数据是被拖元素的 id ("drag1")
把被拖元素追加到放置元素（目标元素）中 -->

<!-- 
canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成： 
-->
<script type="text/javascript">
	var c = document.getElementById("myCanvas");
	var cxt = c.getContext("2d");
	cxt.fillStyle = "#ff0000"
	cxt.fillRect(0,0,150,75);
</script>
<!-- 
getContext("2d") 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 
-->

<script type="text/javascript">

	var c=document.getElementById("myCanvas");
	var cxt=c.getContext("2d");
	cxt.moveTo(10,10);
	cxt.lineTo(150,50);
	cxt.lineTo(10,50);
	cxt.stroke();

</script>

<script type="text/javascript">

	var c=document.getElementById("myCanvas");
	var cxt=c.getContext("2d");
	cxt.fillStyle="#FF0000";
	cxt.beginPath();
	cxt.arc(70,18,15,0,Math.PI*2,true);
	cxt.closePath();
	cxt.fill();

</script>

<script type="text/javascript">

	var c=document.getElementById("myCanvas");
	var cxt=c.getContext("2d");
	var grd=cxt.createLinearGradient(0,0,175,50);
	grd.addColorStop(0,"#FF0000");
	grd.addColorStop(1,"#00FF00");
	cxt.fillStyle=grd;
	cxt.fillRect(0,0,175,50);

</script>

<script type="text/javascript">

	var c=document.getElementById("myCanvas");
	var cxt=c.getContext("2d");
	var img=new Image()
	img.src="flower.png"
	cxt.drawImage(img,0,0);

</script>

<!-- 
什么是SVG？
SVG 指可伸缩矢量图形 (Scalable Vector Graphics)
SVG 用于定义用于网络的基于矢量的图形
SVG 使用 XML 格式定义图形
SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失
SVG 是万维网联盟的标准 -->

<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="190">
	<polygon points="100,10 40,180 190,60 10,60 160,180"
	style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;" />
</svg>

<!-- 是否独立，是否含有对外部文件的引用 -->
<?xml version="1.0" standalone="no"?>

<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" 
	"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<svg width="100%" height="100%" version="1.1"
xmlns="http://www.w3.org/2000/svg">

<circle cx="100" cy="50" r="40" stroke="black"
stroke-width="2" fill="red"/>

</svg>

<!-- 
矩形 <rect>
圆形 <circle>
椭圆 <ellipse>
线 <line>
折线 <polyline>
多边形 <polygon>
路径 <path> -->

<!-- opacity 透明度 rx ry 圆角  -->
<!-- 椭圆 cx 属性定义圆点的 x 坐标
cy 属性定义圆点的 y 坐标
rx 属性定义水平半径
ry 属性定义垂直半径 -->

<!-- 
<path> 标签用来定义路径。
下面的命令可用于路径数据：
M = moveto
L = lineto
H = horizontal lineto
V = vertical lineto
C = curveto
S = smooth curveto
Q = quadratic Belzier curve
T = smooth quadratic Belzier curveto
A = elliptical Arc
Z = closepath
注释：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。 -->

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" 
	"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg">

	<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:1; stroke:rgb(0,0,0)"/>

	<rect x="20" y="20" width="250" height="250" style="fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9"/>

	<rect x="20" y="20" width="250" height="250" style="fill:blue;stroke:pink;stroke-width:5;opacity:0.9"/>

	<rect x="20" y="20" rx="20" ry="20" width="250" height="100" style="fill:red;stroke:black;stroke-width:5;opacity:0.5"/>

	<ellipse cx="300" cy="150" rx="200" ry="80" style="fill:rgb(200,100,50);stroke:rgb(0,0,100);stroke-width:2"/>

	<line x1="0" y1="0" x2="300" y2="300" style="stroke:rgb(99,99,99);stroke-width:2"/>

	<polygon points="220,100 300,210 170,250" style="fill:#cccccc;stroke:#000000;stroke-width:1"/>

	<polyline points="0,0 0,20 20,20 20,40 40,40 40,60" style="fill:white;stroke:red;stroke-width:2"/>

</svg>


<!-- 
Canvas
依赖分辨率
不支持事件处理器
弱的文本渲染能力
能够以 .png 或 .jpg 格式保存结果图像
最适合图像密集型的游戏，其中的许多对象会被频繁重绘
SVG
不依赖分辨率
支持事件处理器
最适合带有大型渲染区域的应用程序（比如谷歌地图）
复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
不适合游戏应用 -->

<!-- 
HTML5 提供了两种在客户端存储数据的新方法：
localStorage - 没有时间限制的数据存储
sessionStorage - 针对一个 session 的数据存储 

HTML5 使用 JavaScript 来存储和访问数据。

sessionStorage 方法针对一个 session 进行数据存储。
当用户关闭浏览器窗口后，数据会被删除。

-->

<script type="text/javascript">
	localStorage.lastname="Smith";
	document.write(localStorage.lastname);
</script>

<script type="text/javascript">
	if (localStorage.pagecount){
		localStorage.pagecount=Number(localStorage.pagecount) +1;
	}else{
		localStorage.pagecount=1;
	}
	document.write("Visits "+ localStorage.pagecount + " time(s).");
</script>

<script type="text/javascript">
	sessionStorage.lastname="Smith";
	document.write(sessionStorage.lastname);
</script>


<!-- 
使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。 

manifest 文件的建议的文件扩展名是：".appcache"。
请注意，manifest 文件需要配置正确的 MIME-type，
即 "text/cache-manifest"。必须在 web 服务器上进行配置
CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）

一旦应用被缓存，它就会保持缓存直到发生下列情况：
- 用户清空浏览器缓存
- manifest 文件被修改（参阅下面的提示）
- 由程序来更新应用缓存
-->

CACHE MANIFEST
# 2012-02-21 v1.0.0
/theme.css
/logo.gif
/main.js

NETWORK:
login.asp

FALLBACK:
/html5/ /404.html

<!-- 
	web worker 是运行在后台的 JavaScript，不会影响页面的性能 -->
	<!DOCTYPE html>
	<html>
	<body>

		<p>计数: <output id="result"></output></p>
		<button onclick="startWorker()">开始 Worker</button> 
		<button onclick="stopWorker()">停止 Worker</button>
		<br /><br />

		<script>
			var w;

			function startWorker(){
				if(typeof(Worker)!=="undefined"){
					if(typeof(w)=="undefined"){
						w=new Worker("/example/html5/demo_workers.js");
					}
					w.onmessage = function (event) {
						document.getElementById("result").innerHTML=event.data;
					};
				}else{
					document.getElementById("result").innerHTML="Sorry, your browser does not support Web Workers...";
				}
			}

			function stopWorker(){ 
				w.terminate();
			}
		</script>

	</body>
	</html>

<!-- 
demo_workers

var i=0;

function timedCount(){
	i=i+1;
	postMessage(i);
	setTimeout("timedCount()",500);
}

timedCount();
-->

<!-- 
由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象：
window 对象
document 对象
parent 对象 -->

<!-- 
Server-Sent 事件 - 单向消息传递
Server-Sent 事件指的是网页自动获取来自服务器的更新
EventSource 对象用于接收服务器发送事件通知

-->

<!DOCTYPE html>
<html>
<body>
	<h1>获得服务器更新</h1>
	<div id="result"></div>

	<script>
		if(typeof(EventSource)!=="undefined"){
			var source=new EventSource("/example/html5/demo_sse.php");
			source.onmessage=function(event){
				document.getElementById("result").innerHTML+=event.data + "<br />";
			};
		}else{
			document.getElementById("result").innerHTML="Sorry, your browser does not support server-sent events...";
		}
	</script>

</body>
</html>

<?php
header('Content-Type: text/event-stream');
header('Cache-Control: no-cache');

$time = date('r');
echo "data: The server time is: {$time}\n\n";
flush();
?>